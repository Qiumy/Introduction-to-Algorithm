## 第1章 开始

- 标准库定义的所有名字都在命名空间std中。
- 注释界定符不能嵌套
- 当遇到文件结束符（end-of-file），或者遇到一个无效输出是，istream对象的状态就会变为无效。
- 包含来自标准库的头文件是，应该使用尖括号（<>）包围文件；对于不属于标准库的头文件，则用双引号（""）包围。

# 第I部分 C++基础

## 第2章 变量和基本类型

- 字面值常量

字符和字符串字面值

| 前缀   | 含义           | 类型       |
| ---- | ------------ | -------- |
| u    | Unicode 16字符 | char16_t |
| U    | Unicode 32字符 | char32_t |
| L    | 宽字符          | wchar_t  |
| u8   | UTF-8        | char     |


整型和浮点型字面值

| 后缀       | 类型          |
| -------- | ----------- |
| u or U   | unsigned    |
| l or L   | long        |
| ll or LL | long long   |
| f or F   | float       |
| l or L   | long double |

- 声明和定义

变量声明规定了变量的类型和名字，在这一点上和定义相同。但除此紫外，顶外还申请存储空间，也可能为变量赋一个初始值。

在变量名前添加关键字extern，可以声明一个变量而非定义它。

```c++
extern int i;   // 声明i而非定义i
int j;          // 声明并定义j
extern double pi = 3.1416  // 定义
```

在函数内部，如果试图初始化一个有extern关键字标记的变量，将引发错误。

变量只能被定义一次，但可以被多次声明。

- 指针

指针的值（即地址）应属于下列4种状态之一：

1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针，意味着指针没有指向任何对象
4. 无效指针，也就是上述情况之外的其他值。

使用`nullptr`初始化指针，同时尽量避免使用`NULL`。

- const限定符

默认状态下，const对象仅在文件内有效（如果想在多个文件之间共享const对象，必须在变量定义之前添加extern关键字）。

引用的类型必须与其所引用的对象的类型一致，但是有两个例外（1. 初始化常量引用时允许用任意表达式作为初始值 2. 存在继承关系的类）

指向常量的指针不能改变其所指对象的值。

常量指针必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。把*放在const关键字之前用来说明指针是一个常量。

- auto类型说明符（C++11新增）

让编译器去分析表达式所属的类型。auto定义的变量必须要有初始值。

- decltype类型指示符（C++11新增）

其作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。

```c++
decltype(f()) sum = x;   // sum的类型就是函数f的返回类型
```

- 预处理器概述

预处理器就是在编译之前执行的一段程序，可以部分地改变我们所写的程序。例如#include。

头文件保护符。预处理变量有两种状态：已定义和未定义。

```c++
#ifndef DATA_H
#define DATA_H
#include <string>
struct data {
  std::string name;
  unsigned year = 0;
  double weight = 0.0;
};
#endif
```

## 第3章字符串、向量和数组

### 标准库类型string

- 直接初始化和拷贝初始化

```c++
string s5 = "hiya"; // 拷贝初始化
string s6("hiya");  // 直接初始化
string s7(10, 'c'); // 直接初始化
```

- 在执行读取操作时，string对象会自动忽略开头的空白。
- 标准库允许把字符字面值和字符串字面值转换成string对象。当string对象和字符串字面值混在一条语句中使用时，必须保证每个加法运算符（+）的两侧的运算对象至少有一个是string。

```c++
string s4 = s1 + ",";             // 正确
string s5 = "hello" + ",";        // 错误
string s6 = s1 + "," + "world";   // 正确
string s7 = "hello" + "," + s2;   // 错误
```

- 范围for语句

```c++
for (declaration : expression)
  statement
string str("some string");
for (auto c : str)
  cout << c << endl;
```

- 使用范围for语句改变字符串中的字符

```c++
string str("some string");
for (auto &c : str)
	c = toupper(c);
cout << str << endl;
```

- 可以使用下标或者迭代器访问string对象中的单个字符。


- 逻辑与运算符：只有当左侧对象为真的时候才会检查右侧运算对象的情况。

### 标准库类型vector

- 初始化vector对象

```c++
#include <vector>
vector<int> ivec;						// 初始状态为空
vector<int> ivec2(ivec);				// 拷贝赋值
vector<int> ivec_copy = ivec;			// 拷贝赋值
vector<string> v1{"a", "an", "the"};	// 列表初始化
vector<int> ivec3(10, -1);				// 创建指定数量的元素
vector<string> svec(10, "hi");			// 创建指定数量的元素
vector<int> ivec4(10);					// 10个元素，每个初始为0
vector<string> svec2(10);				// 10个元素，每个初始为空的string对象
```

- vector的元素可以进行比较，当元素的值可以比较的时候。

###  迭代器

- begin成员负责返回指向第一个元素的迭代器，end成员则负责指向容器（或string对象）尾元素的下一个位置。

### 数组

## 第4章 表达式

- 求值顺序

对于没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义行为。

```c++
int i=0;
coutn << i << " " << ++i << endl;		// 未定义的
```

- 有四种运算符明确规定了运算对象的求值顺序。逻辑与（&&）：先求左侧运算对象的值，只有当左侧对象为真的时候才会检查右侧运算对象的情况；逻辑或（||）：先求左侧运算对象的值，只有当左侧对象为假的时候，才会计算右侧运算对象的值；条件（? : ）：；逗号（ , ）：


- ```c++
  bool b = true;
  bool b2 = -b;		// b2是true！
  ```

- 参与取余运算的对象必须是整数类型。-(m)/n和m/(-n)都等于-(m/n)，m%(-n)等于m%n，(-m)%n等于-(m%n)。

- 除非必须，否则不用递增递减运算符的后置版本。

- 后置递增运算符的优先级高于解引用运算符。

```c++
cout << *iter++ << endl;
// 等价于
cout << *iter << endl;
++ iter;
```

- 在输出表达式中使用条件运算符

```c++
cout << ((grade < 60)? "fail":"pass");	//输出pass或者fail
cout << (grade < 60)?"fail":"pass";		//输出1或者0
cout << grade < 60? "fail":"pass";		//错误：试图比较cout和60
```

- 类型转换：static_cast和const_cast

## 第5章 语句

- 空语句，空语句只包含一个单独的分号。如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，此时应该使用空语句
- 在程序的某个地方，语法上需要一条语句，但是逻辑上需要多条语句，则应该使用符合语句。有时候需要将多条语句用花括号括起来，从而把语句序列转变成块。空块的作用等于空语句。
- 悬垂的else：当if分支多余else分支时，else分支与离他最近的尚未匹配的if匹配。

### switch语句

- 如果表达式和某个case标签的值匹配成功，程序从该标签之后的第一条语句开始执行，指导到达switch结尾或者是遇到一条break语句为止。
- case标签必须是整型常量表达式。
- 如果需要为某个分支定义并初始化一个变量，则应该把变量定义在块内，从而确保后面所有的case标签都在变量的作用域之外。

```c++
case true:
	// 因为程序可能绕开下面的初始化语句，所以switch语句不合法
	string file_name;		// 错误：控制流绕过一个隐式初始化变量
	int ival = 0;			// 错误：控制流绕过一个显示初始化变量
	int jval;				// 正确：因为jval没有初始化
	break；
case false:
	jval = next_num();		// 正确：给jval赋值
	if(file_name.empty())	// file_name在作用域内，但是没有被初始化
      	//...
```

### 迭代语句

- for语句的语法形式

```c++
for (init-statement; condition; expression)
```

for语句执行流程：1.首先执行一次init-statement 2. 判断condition，如果条件为真，执行循环体；否则条件终止 3. 执行expression

- 和其他声明一样，init-statement可以定义多个对象，但是只能有一条声明语句。
- 范围for语句

```c++
for (declaration : expression)
  statement
```

expression表示必须是一个序列，declaration定义一个变量，序列中的每个元素都得能转换成该变量的类型。确保类型相容最简单的办法是使用auto类型说明符。

- do while语句

```c++
do
  statement
while (condition)
```

求condition的值之前首先执行一次statement，condition不能为空。condition使用的变量必须定义在循环体之外。

### 跳转语句

- break语句负责终止离它最近的while、do while、for或switch语句，并从这些语句之后的第一条语句开始继续执行。
- continue语句中断当前的迭代，但仍然继续执行循环。continue语句只能出现在for、while和do while循环内部，对于switch语句，只有当switch语句嵌套在迭代语句内部时，才能在switch中使用continue。

### try语句块和异常处理

- 异常处理机制为程序中断异常检测和异常处理这两部分的协作提供支持。C++中的异常处理主要包括：throw表达式、try语句块、一套异常类。
- 每个标准异常类都定义了名为what的成员函数，这些函数没有参数，返回值是C风格字符串。
- 如果一段程序没有try语句且发生了异常，系统就会调用terminate函数并终止当前程序的执行。

## 第6章 函数

- 典型的函数定义包括以下部分：返回类型、0个或多个形参组成的列表以及函数体。
- 实参是形参的初始值，尽管实参与形参存在对应关系，但是没有规定实参的求值顺序。编译器能以任意可行的顺序对实参求值。
- 函数的返回类型不能是数组类型或函数类型。
- 函数声明和函数定义类似，唯一的区别就是函数声明无需函数体，用一个分号替代即可。建议函数在头文件声明而在源文件中定义。

### 参数传递

- 传值参数，初始化一个非引用类型的变量时，初始值被拷贝给变量。此时对变量的改动不会影响初始值。（在C++中，建议使用引用类型的形参替代指针。）
- 使用引用避免拷贝，如果函数无需改变形参的值，最好将其声明为常量引用。
- 数组有两个特殊的性质：1，不允许拷贝数组 2. 使用数组（通常）将其转换成指针。
- 数组引用形参的例子

```c++
// 正确：形参是数组的引用，维度是类型的一部分
void print(int (&arr) [10]){
	for (auto elem: arr)
      	cout << elem << endl;
}

int i=0, j[2]={0,1};
int k[10] = {0,1,2,3,4,5,6,7,8,9};
print(&i);		// 错误
print(j);		// 错误
print(k);		// 错误
```

- 含有可变形参的函数：initializer_list形参

### 返回类型和return语句

- 不要返回局部对象的引用或指针

```c++
// 严重错误：这个函数试图返回局部对象的引用
const string &manip(){
  string ret;
  if(!ret.empty())
    return ret;		// 错误：返回局部对象的引用
  else
    return "Empty"; // 错误：“Empty”是一个局部变量
}
```

两条return语句都指向了不再可用空间。

### 函数重载

- 对于重载函数来说，它们应该在形参数量或形参类型上有所不同。
- 重载函数是的三种可能结果：找到最佳匹配、无匹配、二义性调用
- 如果在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名。

### 特殊用途语言特性

- 默认实参：一旦某个形参被赋予了默认值，它后面的所有形参必须有默认值。对于给定作用域中一个形参，只能被赋予一次默认形参。
- 局部变量不能作为默认实参。
- assert预处理宏：`assert(expr)`

### 函数指针

```c++
pf = lengthCompare;
pf = &lengthCompare;

bool b1 = pf("hello", "goodbye");
bool b2 = (*pf)("hello", "goodbye");
bool b3 = lengthCompare("hello", "goodbye");
```

## 第7章 类

- 类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现分离的编程技术。封装实现了类的接口和实现的分离。
- 只有当类没有生命任何构造函数时，编译器才会自动地生成默认构造函数。
- 对象在几种情况下会被拷贝：初始化变量以及以值的方式传递或者返回一个对象。
- 直到类被定义之后数据成员才能被声明成这种类型。换句话说，我们必须首先完成类的定义，然后编译器才能知道存储该数据成员需要多少空间。因为只有当类全部完成后类才算被定义，所以一个雷的成员类型不能是该类自己。然而，一旦一个类的名字出现后，他就被认为是声明过了（但尚未定义），因此类允许包含指向它自身类型的引用或指针。
- 类的定义分成两步处理：编译成员声明、直到类全部可见之后才编译函数体。换言之，编译器处理完类中的全部声明后才会处理成员函数的定义。
- 建议使用构造函数初始值
- 成员的初始化顺序和它们在类定义中出现顺序一致。
- 使用默认构造函数

```c++
Sales_data obj();		// 错误：声明了一个函数而非对象
Sales_data obj2;		// 正确：obj2是一个对象而非函数
```

