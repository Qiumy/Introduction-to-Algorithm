# 散列表

## 直接寻址表和散列表

直接寻址表，使用一个数组T对应全域U中的一个关键字。对于查找、插入、删除的时间复杂度均为O(1)。

- 直接寻址技术的缺点非常明显：如果全域U很大，则在一台标准计算机可用内存容量中，存储大小为|U|的表T不太实际。
- 此外，实际存储的关键字集合K相对U来说可能很小，使得分配给T的大部分空间都将浪费掉。

散列表所需的存储空间比直接寻址表少得多，同时散列表中查找一个元素的优势得到保持，仍为O(1)。

在直接寻址方式下，具有关键字k的元素被存放在槽k中。在散列方式下，该元素存放在槽h(k)中；即利用散列函数h，由关键字k计算出槽的位置。

### 通过链接法解决冲突

链接法中，把散列到同一槽中的所有元素都放在一个链表中。

最坏情况下查找时间为theta(n)。

散列表的平均性能依赖于所选取的散列函数h，将所有关键字集合分布在槽位上的均匀程度。

## 散列函数

一个好的散列函数应（近似地）满足简单均匀散列假设：每个关键字都被等可能的散列到m个槽位中的任何一个，并与其它关键字已散列到哪个槽位无关。

- 多数散列函数都假定关键字的全域为自然数集。如果所给的关键字不是自然数，就需要找到一种方法来将它们转换为自然数。

### 除法散列法

通过关键字k除以槽位m的余数来映射到某个槽位中。

```python
hash(k) = k mod m
```

应用除法散列时，应注意m的选择，m不应该是2的幂，通常选择与2的幂不太接近的质数。

### 乘法散列法

乘法方法包含两个步骤，第一步用关键字k乘上常数A(0<A<1),并取出小数部分，然后用m乘以这个值，再取结果的底(floor)。

```python
hash(k) = floor( m (kA mod 1) )
```

乘法的一个优点是对m的选择没有什么特别的要求，一般选择它为2的某个幂。一般取A=(√5-1)/2=0.618比较理想。

### 全域散列

随机的选择散列函数，使之独立于要存储的关键字。在执行开始时，就从一族仔细设计的函数中，随机的选择一个作为散列函数，随机化保证了没有哪一种输入会始终导致最坏情况发生。

##  通过开放寻址法解决冲突

在开放寻址法中，所有的元素都存放在散列表中。散列表可能会被填满，以至于不能插入任何新的元素。如果有冲突发生，就会尝试另外的单元，直到找出空的单元为止。

```python
h(k, i) = (h`(k) + f(i)) mod m, i=0,1,...m-1, f(0) = 0
```

### 线性探测

```python
h(k, i) = (h`(k) + i) mod m
```

随着被占用槽的增加，平均查找时间也会不断增加。当一个空槽前有i个满的槽时，该空槽为下一个被占用槽的概率是(i+1)/m。

### 平方探测

```python
h(k, i) = (h`(k)+c1*i+c2*i^2) mod m
```

平方探测中，如果表的一半为空，并且表的大小是质数，保证能够插入一个新的元素。

### 双重散列

```python
h(k, i) = (h1(k) + i*h2(k)) mod m
```

为了能查找整个散列表，值h2(k)要和m互质。确保这个条件成立的一种方法是取m为2的幂，并设计一个总产生奇数的h2；另一种方法是取m为质数，并设计一个总产生较m小的正整数的h2。

